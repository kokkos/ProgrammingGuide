\section{Towards Generic Parallel Programming}\label{chap:background}

A programming model exposes constrained semantics that the programmer uses to express intent. Absent a programming model providing additional constraints, the semantics of C-like languages can lead to sequential thinking and execution. Parallel programming models expose parallel semantics to enable developers to create performance-portable code. This is commonly achieved by adding annotations to the base programming language, often through \emph{pragma} clauses or similar language extensions. Other methods expose such semantics through library calls or new languages. All three approaches are conceptually suitable to represent programming paradigms such as tasking, data parallelism, and other patterns. Some representatives are the OpenMP programming model~\cite{OPENMP}, threading libraries, or languages like Erlang\cite{ERLANG} in which parallelism is a first-class citizen. In general, it is up to the parallel programming model implementer to expose language constructs or library interfaces (APIs) that combine convenience to the programmer with sufficiently constrained semantics to map the program execution to the parallel computer hardware efficiently and correctly. Questions of which semantic information is needed, what paradigm to present, and by what syntactic means to do so span an exciting design space that is well worth exploring.

 Figure~\ref{figSemCapture} shows the four properties that constitute a parallel programming model and its design. We call it the semantic capture.

\begin{figure}[h]
\begin{Verbatim}[frame=leftline]
Constrained Semantics: memory allocations, 
memory movement, execution parameters
Parallel Paradigms: patterns, tasks
Expression: language 
Control Paradigm: prescriptive, descriptive
\end{Verbatim}
\caption{Semantic capture: a set of constrained semantics, parallel paradigms, expression and concern define key properties a parallel programming model.}
\label{figSemCapture}
\end{figure}

\emph{Constrained Semantics} provided by the programmer to the parallel programming model can be grouped into information to express intent or correctness and properties that control critical performance aspects. They address the question of \emph{what}, \emph{where} and \emph{how}. In the context of parallel programming, these correspond to defining which code portion to parallelize, where to run the code, where to access the data, and how to run that parallel code. Synchronization primitives may be considered part of the \emph{what}, and information on the execution properties such as data placement or memory access type may be considered as part of the \emph{how}. Application logic is expressed following a \emph{paradigm} implemented in a \emph{programming language}.

A \emph{Parallel Paradigm} is an abstract representation with the purpose of facilitating the programmer's understanding of programming rules and program behavior. Which programming paradigm to choose depends on several considerations. Parallel patterns allow the programmer to permit concurrent execution for commonly occurring programming patterns such as loop constructs. Tasking is a paradigm that supports the expression of interdependent work items needed for irregular algorithms. Distributed and correctness-oriented programming models may implement actor-based programming, where each unit of execution represents an actor who communicates over predefined communication channels. This paradigm eliminates accesses to shared state and aligns well with message passing programming (MPI). The execution model and memory model aspects of a programming model define its behavior. That is, it defines the relationship between abstract concepts and program execution on the given architecture.

A language defines the syntax of the parallel semantic. Annotations-based  languages add semantic information to the base language through pragmas while embedded programming models rely on the base language and offer additional programming interfaces to capture information. Their semantic is defined in the API specification. 

Lastly, a programming model must divide responsibility between the developer and the model. We refer to is as defining the \emph{Control Paradigm}. In practice, this is a choice between defining a descriptive and prescriptive semantics. Descriptive semantics require a developer to express intent. The implementation is the responsibility of the programming model and of the underlying toolchain. Prescriptive semantics require the developer to specify the mechanisms by which their intent will be implemented. In a prescriptive model, developer success is tied to their knowledge of implementation mechanisms. In a descriptive model that success is tied to the developer's ability to accurately describe their requirements and the toolchain's ability to turn that into an implementation. 

Figures~\ref{figOMPLike} and~\ref{figKokkosLike} show two code examples using the aforementioned parallel programming syntaxes. While both programming models implement the same programming paradigm (parallel patterns), Figures~\ref{figOMPLike} extends the base programming language through pragma annotations. Both, pragma annotations and an API call as shown in Figure~\ref{figKokkosLike} can have a descriptive or prescriptive semantic of describing a parallel loop construct. It is up to the programming model specification to make further definitions regarding separation of concern.

Both examples provide the semantic information on what to parallelize, however, they do not expose enough abstraction primitives that would allow to map parallel execution on modern architectures efficiently. In order to define what further information is needed to express concurrency on modern computer architectures, it is important to define an~\emph{abstract machine representation} first. In the following chapters we use the words \emph{representation} and \emph{model} interchangeably. In this work the abstract machine model does not describe a computer in terms of automata theory but in terms of physical or functional components.

\begin{figure}
\begin{Verbatim}[frame=leftline]
# pragma model parallel loop
for ( size_t i = 0; i < N; ++i) {
 /* loop body */
}
\end{Verbatim}
\caption{Annotations-based programming models extend the semantic of the base language through pragma annotations.}
\label{figOMPLike}
\end{figure}

\begin{figure}
\begin{Verbatim}[frame=leftline]
model::parallel_for (N, [=] ( const size_t i) {
  /* loop body */
});
\end{Verbatim}
\caption{Embedded parallel programming uses the base language and relies on programming interfaces to capture information.}
\label{figKokkosLike}
\end{figure}
