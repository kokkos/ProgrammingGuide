\section{Towards Generic Parallel Programming}\label{chap:background}

A programming model exposes constrained semantics to the programmer which the programmer uses to express intent. Absent an embedded programming model, the semantics of C-like languages can lead to sequential thinking and execution. Parallel programming models expose parallel semantics to enable developers to create performance portable code. This is commonly achieved by adding semantic value to the base programming language, often referred to as programming with \emph{pragma} annotations. Other methods expose such semantics through library calls or new languages. All three approaches are conceptually suitable to represent programming paradigms such as tasking, parallel patterns and others. Some representatives are the OpenMP programming model~\cite{CITEOPENMP}, threading libraries, or languages like Erlang in which parallelism is a first-class citizen. In general, it is up to the parallel programming model to expose language constructs or library interfaces (APIs) such that they combine convenience to the programmer with semantics sufficient to map the program execution to the parallel computer hardware efficiently and correctly. Questions of which semantic information is needed, what paradigm to present and by what syntactical means span an exciting design space worth exploring.

 Figure~\ref{figSemCapture} shows the four properties that constitute a parallel programming model and its design. We call it the semantic capture.

\begin{figure}[h]
\begin{Verbatim}[frame=leftline]
Constrained Semantics: memory allocations, memory movement, parallel kernels
Parallel Paradigms: patterns, tasks
Expression: language 
Concern: prescriptive, descriptive
\end{Verbatim}
\caption{Semantic capture - a set of constrained semantics, parallel paradigms, expression and concern define key properties a parallel programming model.}
\label{figSemCapture}
\end{figure}

Constrained semantics provided by the programmer to the parallel programming model can be grouped into information to express intent and properties. They address the question of \emph{what}, \emph{where} and \emph{how}. In the context of parallel programming, these correspond to defining which code portion to parallelize, where to run and access and how to run that parallel code. Synchronization primitives may be considered as part of the what and information on the execution properties such as data placement or memory access type as the how. Semantics are expressed following a paradigm and a programming language.

The parallel programming paradigm is an abstract ~\emph{representation} with the purpose of facilitating the programmer's understanding of programming rules and program behavior. Which programming paradigm to chose depends on several considerations. Parallel-patterns allow to express concurrency for commonly occurring programming patterns such as loop constructs. Tasking is a paradigm that support the expression of concurrent loops as well as irregular algorithms. Distributed and correctness-oriented programming models may implement actor-based programming. In this programming model, each unit of execution represent an actor who communicates over predefined communication interfaces. This paradigm eliminates accesses to shared state and align well with message passing programming (MPI). The execution model and memory model of a programming model defines behavior. That is, it defines the relationship between abstract concepts and program behavior on the given architecture.

Lastly, a language defines the syntax of the parallel semantic. Annotations-based  languages add semantic information to the base language through pragmas while embedded programming models rely on the base language and offer additional programming interfaces to capture information. Their semantic is defined in the API specification. 

Lastly, a programming model must divide responsibility between the developer and the model. We refer to is as defining the concern. In practice, this is a choice between defining a descriptive and prescriptive semantics. Descriptive semantics require a developer to express intent. The implementation is the responsibility of the programming model and of the underlying toolchain. Prescriptive semantics require the developer to specify the mechanisms by which their intent will be implemented. In an prescriptive model, developer success is tied to their knowledge of implementation mechanisms. In a descriptive model that success is tied to the developer's ability to accurately describe their requirements and the toolchain's ability to turn that into an implementation. 

Figures~\ref{figOMPLike} and~\ref{figKokkosLike} show examples of two sample applications using the aforementioned parallel programming syntaxes. While both programming models implement the same programming paradigm (parallel patterns), Figures~\ref{figOMPLike} extends the base programming language through pragma annotations. Both, pragma annotations and an API call as shown in Figure~\ref{figKokkosLike} can have a descriptive or prescriptive semantic of describing a parallel loop construct. It is up to the programming model specification to make further definitions regarding separation of concern.

Both examples provide the semantic information on what to parallelize, however, they do not expose enough abstraction primitives that would allow to map parallel execution on modern architectures. In order to define what further information is needed to express concurrency on modern computer architectures, it is important to define an~\emph{abstract machine representation} first. In the following chapters we use the words \emph{representation} and \emph{model} interchangeably. In this work the abstract machine model does not describe a computer in terms of automata theory but in terms of physical or functional components.

\begin{figure}
\begin{Verbatim}[frame=leftline]
# pragma model parallel loop
for ( size_t i = 0; i < N; ++i) {
 /* loop body */
}
\end{Verbatim}
\caption{Annotations-based programming models extend the semantic of the base language through pragma annotations.}
\label{figOMPLike}
\end{figure}

\begin{figure}
\begin{Verbatim}[frame=leftline]
model::parallel_for (N, [=] ( const size_t i) {
  /* loop body */
});
\end{Verbatim}
\caption{Embedded parallel programming uses the base language and relies on programming interfaces to capture information.}
\label{figKokkosLike}
\end{figure}