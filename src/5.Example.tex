\section{Example}\label{chap:kokkosExample}

In this section we provide an example of an application written in the Kokkos programming model. The code in Figure~\ref{fig:KokkosExample} shows a parallel matrix-vector multiplication implemented as two nested loops. The outer loop, that is the outer~\emph{parallel\_for}, iterates over the rows of the input matrix and of the input vector while the inner loop iterates over elements in each row. Since the inner loop potentially executes in parallel, the update operation of the aggregating variable~\emph{y\_tmp} must be protected against data races. Using the~\emph{parallel\_reduction} pattern, the programming model provides a local variable to that loop iteration. Once the computation finishes, the final result of the reduction operation is stored in the output vector~\emph{y} at the row index~\emph{e}.  
As a first step, a Kokkos application must call ~\emph{Kokkos::initialize}. Initialization and finalization are required and serve the purpose of setting up the underlying runtime. 
Further, the example code shows the use of the ~\emph{Kokkos::View} abstraction. 

Views are abstractions that represent data. Naturally, data can reside in host memory where it is accessible to the host execution space or on device memory where it is accessible to the device execution space. In this example, copies of the views are created to make them accessible by the host process. This is accomplished by calling the ~\emph{create\_mirror\_view} function. 

If the original data is already accessible by the host process, this function returns a ~\emph{View} referencing the same allocation. In real applications, a host-accessible allocation is necessary to allow I/O operations during filesystem access. To move data to the respective memory space that is accessible by the parallel execution resources, the function ~\emph{deep\_copy} has to be invoked. In case two view objects are aliased, this operation results in a~\emph{no-op}. 

Consequently, the simple example does not explicitly specify a memory space where the data lives in. However, Kokkos ensures that the defaults for parallel execution and data allocations match. 

Taking a closer look at the loop step shows the hierarchical expression of concurrency. This is accomplished by using the ~\emph{Kokkos::TeamPolicy}. For each row of~\emph{A} a team of threads is launched, where the size of the team is not further specified. When using a ~\emph{TeamPolicy} the operator of the lambda expression does not receive an index, but rather a handle to the team of threads. 
This handle provides the team identifier \emph{e}, and is subsequently handed to the nested parallel execution policies. The nested reduction requires the operator of the nested lambda to take a reference to the thread-local reduction variable (called here ~\emph{y\_tmp}) in addition to the loop index. It then writes the result to the correct position of the output vector. 
The parallel loops are followed by a call to \emph{Kokkos::fence}. This ensures that the execution of the parallel code is completed before copying the results back to the host memory space. This is implemented through the~\emph{Kokkos::deep\_copy} call. Lastly, the Kokkos application calls~\emph{Kokkos::finalize}.

While this example can only provide a brief insight into Kokkos, we recommend to the interested reader to access further resources. Resources include example applications for individual Kokkos features, tutorials with multiple days worth of lectures and exercises, a programming guide, and API documentation. Source code examples as well as the tutorial are located in the Kokkos repository~\cite{KOKKOS_REPO}. The tutorial is intended for students with minimal or even no prior knowledge of parallel programming. It introduces concepts of parallel programming using Kokkos through a series of lectures and hands-on exercises that build upon each other and gradually introduce new concepts. The programming guide is available on-line~\cite{KOKKOS_WIKI}. 

\begin{figure}
\begin{small}
\begin{minted}[fontsize=\small]{c++}
#include<Kokkos_Core.hpp>
int main(int argc, char* argv[]) {
  Kokkos::initialize(argc,argv);
  {
    Kokkos::View<double*> x("x", M);  
    Kokkos::View<double*> y("y", N);
    Kokkos::View<double**,Kokkos::LayoutRight> 
                                  A("A", N, M);  
    auto x_h = Kokkos::create_mirror_view(x);
    auto y_h = Kokkos::create_mirror_view(y);
    auto A_h = Kokkos::create_mirror_view(A);
    Kokkos::deep_copy(x,x_h);
    Kokkos::deep_copy(A,A_h);    

    Kokkos::parallel_for("outer", 
      TeamPolicy<>(N,AUTO),
      [=](const member_type &team_handle) {
        const int e = team_handle.league_rank();
        Kokkos::parallel_reduce( 
          TeamThreadRange(team_handle, M),
          [=](const int & i, double & y_tmp) {
            y_tmp += A(e, i) * x(i);
          }, 
          y(e));
    }); 
    Kokkos::fence();
    Kokkos::deep_copy(y_h,y);
    //output_result_on_host(y_h);
  }
  Kokkos::finalize();
}
\end{minted}
\end{small}
\caption{This example application written in Kokkos shows the use of a~\emph{view}-type and a parallel for loop using a ~\emph{TeamPolicy} and a nested parallel reduction. }
\label{fig:KokkosExample}
\end{figure}

