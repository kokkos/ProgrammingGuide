\subsection{Back-end Support}\label{chap:kokkosBackend}



Explain fence guard, KOKKOS\_LAMBDA, 


The important consideration here is that the method of compiling code for different execution spaces and the dispatch of kernels to instances is abstracted by the Kokkos model. This unburdens application programmers from writing algorithms in hardware specific languages.

\begin{figure}
\begin{small}
\begin{Verbatim}[frame=leftline]
int main(int argc, char* argv[]) {
  Kokkos::initialize(argc,argv);
  {
    int N = atoi(argv[1]);
    Kokkos::View<int*> a("A", N);  
    Kokkos::parallel_for(
    Kokkos::RangePolicy<Kokkos::OpenMP>(N,
    KOKKOS_LAMBDA (const int & i)
    {
      a(i)=i;
    }); 
  }
  Kokkos::finalize();
}
\end{Verbatim}
\end{small}
\caption{An application written in Kokkos shows the use of a~\emph{view}-type and parallel for loop.}
\label{fig:KokkosExample}
\end{figure}



\begin{figure}
\begin{small}
\begin{Verbatim}[frame=leftline]

template <class FunctorType, class... Traits>
class ParallelFor<FunctorType, 
    Kokkos::RangePolicy<Traits...>, 
    Kokkos::OpenMP> 
{
  ...
private:
  ... exec_range(const FunctorType& functor, 
  const Member i_beg,
  const Member i_end) 
  {
    for (Member i = i_beg; iwork < i_end; ++i){
      functor(t, i);
    }
  }

public:
  ...
  ... execute() const {(
  #pragma omp parallel num_threads(OpenMP::getPoolSize())
  {
    HostThreadTeamData& data=*(i->get_thread_data());
    ...
    range = data.get_work_partition();
    range(m_functor, range.first + m_policy.begin(),
    range.second + m_policy.begin());
  }
}

\end{Verbatim}
\end{small}
\caption{An application written in Kokkos shows a paralle for loop that .}
\label{fig:KokkosExample}
\end{figure}

%\begin{figure}
%\begin{Verbatim}[frame=leftline]
%double f(){
% typedef Kokkos::Cuda ES;
% typedef Kokkos::CudaSpace MS;
% typedef Kokkos::LayoutLeft LL;
% typedef Kokkos::RangePolicy<ES> Range_policy;
% typedef Kokkos::View<double*, LL, MS> V
% V A( "A", N);
% V::HostMirror h_A = Kokkos::create_mirror_view( A );
% for ( int i = 0; i < N; ++i ) //Initialize on host
%   h_A( i ) = 1;
% Kokkos::deep_copy( A, h_A );
% double result = 0;
% Kokkos::parallel_reduce( "yAx", range_policy( 0, N ), 
%  KOKKOS_LAMBDA ( int i, double &update ) {
%   update += A( i );
% }, result );
% return result;
%}
%\end{Verbatim}
%\caption{Declarative parallel programming provides uses pragma annotations to capture semantic information.}
%\label{figOMPLike}
%\end{figure}

\begin{figure}
\centerline{\includegraphics[width=0.3\textwidth]{img/Build.png}}
\caption{Building workflow}
\label{fig}
\end{figure}